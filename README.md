# Silent MPC Correlation Engine

A high-performance C++20 implementation of correlation generation for secure multi-party computation protocols.

## Overview

This project provides a portable, streaming correlation service for MPC preprocessing. The implementation supports multiple algebraic domains including GF(2), GF(q), and Z_{2^k} rings with pluggable backend architectures. The system features operational safety through crash recovery with zero-reuse guarantees and is optimized for both LAN and WAN network environments.

The correlation engine uses a stateless design with immutable handles and separate runtime state management. This architecture enables efficient correlation generation while maintaining strong security properties including freshness enforcement, rollback resistance, and query-bounded security through automatic session rotation.

## Core Features

The implementation provides high throughput through optimized PCF evaluation with AVX-512 support. Network adaptability is achieved through automatic backend selection based on network conditions. The tile-based evaluation architecture ensures constant setup cost regardless of tile size, enabling efficient scaling.

Security guarantees include operational contracts that prevent correlation reuse. The epoch-based derivation mechanism survives VM snapshot and restore operations. Session rotation occurs automatically at configurable thresholds to provide query-bounded security. The system implements fail-closed behavior, halting on potential reuse rather than proceeding unsafely.

Operational features include sub-millisecond crash recovery with zero reuse events. Thread-safe block allocation implements waste-not-reuse semantics for concurrent access. The system provides observable epoch rotation and session lifecycle events through monitoring hooks. Built-in network emulation support enables testing under realistic conditions.

## Architecture

The system consists of four main layers. The algebra layer provides a ring-generic interface for GF(2), GF(q), and Z_{2^k} operations. The PCF core implements four-term decomposition for efficient OLE generation. The selective delivery layer offers pluggable OT and DPF backends with a unified interface. The runtime manager handles epoch management, allocation, and session rotation.

Applications interact with the correlation engine through the PCF core, which performs four-term decomposition. The selective delivery backends provide two implementations: an OT-centric approach using IKNP extension and a DPF-centric approach with multi-point batching. Both backends expose the same interface, allowing runtime selection based on network characteristics.

## Prerequisites

Building requires GCC 11 or later, or Clang 14 or later with full C++20 support. CMake version 3.20 or higher is needed for the build system. OpenSSL 1.1.1 or higher provides cryptographic primitives. The system is recommended for Linux platforms where network emulation features are fully supported.

## Building

To build the project, create a build directory and run CMake with the desired build type. The standard process involves creating a build directory, configuring with CMake, and running make with parallel compilation. Testing can be performed using CTest with verbose output enabled.

```bash
mkdir build && cd build
cmake .. -DCMAKE_BUILD_TYPE=Release
make -j$(nproc)
ctest --output-on-failure
```

The build system automatically detects AVX-512 support and enables optimizations when available. If Google Benchmark or GTest libraries are not found, the corresponding performance benchmarks and unit tests are skipped. The paper reproducibility benchmarks are always built as they have no external dependencies beyond OpenSSL and pthreads.

## Basic Usage

To initialize the correlation engine, create a PCF handle with the desired ring type and parameters. The session identifier should be randomly generated using a CSPRNG. The root seed initializes the pseudorandom function tree.

```cpp
#include <silentmpc/pcf/pcf_core.hpp>
#include <silentmpc/algebra/z2k.hpp>
#include <silentmpc/runtime/epoch_manager.hpp>

using namespace silentmpc;
using R = algebra::Z2_64;

auto params = parameters::R2;
auto sid = generate_session_id();
auto root_seed = sample_csprng();
auto [handle, ctx] = pcf::PCFHandle<R>::setup(params, sid, root_seed);
```

Runtime setup requires an epoch manager for persistent state and an allocator for block-based correlation allocation. The epoch manager path should point to rollback-resistant storage.

```cpp
runtime::EpochManager epoch_mgr("/path/to/persist");
runtime::Allocator allocator(sid, epoch_mgr.current(), 1000000);
```

Correlations are generated by allocating blocks and evaluating indices. Each evaluation produces a fresh correlation context that must not be reused.

```cpp
auto block = allocator.allocate_block();
for (auto idx = block.start; idx < block.end; ++idx) {
    auto correlation = handle.eval(idx, ctx, party_id);
}
```

## Backend Selection

The system provides two backend implementations with different performance characteristics. The OT-centric backend uses IKNP extension and is optimized for LAN environments with low latency and limited bandwidth. Communication cost is 2.50 KiB per tile with setup time around 0.16 ms in LAN conditions.

```cpp
using namespace silentmpc::selective_delivery;
auto backend = BackendFactory<R>::create(BackendPolicy::OT);
```

The DPF-centric backend uses multi-point batching and is designed for WAN environments where latency dominates. The non-interactive nature provides resilience in high-latency scenarios. Communication cost is 6.62 KiB per tile with similar setup time in WAN conditions.

```cpp
auto backend = BackendFactory<R>::create(BackendPolicy::DPF);
```

Automatic selection is available based on network hints. The factory selects the appropriate backend considering bandwidth and round-trip time.

```cpp
NetworkHints hints{.bandwidth_mbps = 100, .rtt_ms = 50};
auto backend = BackendFactory<R>::create(BackendPolicy::Auto, hints);
```

## Benchmark Results

The setup cost comparison shows OT-centric and DPF-centric backends under real network conditions. For OT-centric, communication is 2.50 KiB with LAN setup at 0.16 ms and WAN setup at 50.10 ms. For DPF-centric, communication is 6.62 KiB with LAN setup at 0.16 ms and WAN setup at 50.23 ms. The DPF non-interactive nature provides resilience in high-latency environments.

Scalability testing with tile sizes from 2^12 to 2^16 shows constant setup cost. At tile size 2^12 (4K), setup communication is 2.50 KiB with constant setup time. At 2^14 (16K), setup remains 2.50 KiB with constant time. At 2^16 (64K), setup is still 2.50 KiB with constant time. Setup cost is independent of tile size, enabling efficient scaling.

Rollback safety testing at production scale with millions of correlations demonstrates zero reuse events. Crash scenarios show 0 reuse events, 0.82 ms recovery time, and 0.010% wasted ratio. VM rollback scenarios show 0 reuse events, 0.55 ms recovery time, and 0.009% wasted ratio. Zero correlation reuse is guaranteed under crash and rollback scenarios.

## Running Benchmarks

Network emulation requires Linux tc with htb and netem modules. The setup script configures LAN environment with 10 Gbps bandwidth and 0.1 ms RTT, or WAN environment with 100 Mbps bandwidth and 50 ms RTT.

```bash
sudo ./scripts/setup_network.sh lan
sudo ./scripts/setup_network.sh wan
sudo ./scripts/setup_network.sh reset
```

The setup cost benchmark measures actual state transfer over TCP with network emulation. Run the server in one terminal and the client in another terminal.

```bash
./build/benchmarks/setup_cost_benchmark server
./build/benchmarks/setup_cost_benchmark client
```

The tile sensitivity benchmark tests scalability with different tile sizes. Start the server once and run the client with different tile size parameters specified as powers of two.

```bash
./build/benchmarks/tile_sensitivity_benchmark server &
./build/benchmarks/tile_sensitivity_benchmark client 12
./build/benchmarks/tile_sensitivity_benchmark client 14
./build/benchmarks/tile_sensitivity_benchmark client 16
```

The rollback safety benchmark validates epoch management under crash and VM snapshot scenarios. This standalone program requires no separate server process.

```bash
./build/benchmarks/rollback_safety_benchmark
```

## Operational Contracts

The system enforces four operational contracts to guarantee correlation freshness. Contract 0 requires unique session identifiers using 128-bit values from a CSPRNG. Sessions are cryptographically isolated from each other.

Contract 1 implements epoch-bound derivation with a monotonic epoch counter and atomic persistence. The keystream is derived as KDF(sid, epoch, index). Rollback-resistant storage prevents epoch rewind attacks.

Contract 2 provides waste-not-reuse allocation through block-based allocation that prevents concurrent reuse. A durable high-watermark is persisted before returning blocks to callers. During crash recovery, unused indices in a partial session are wasted rather than reused to maintain security.

Contract 3 enables session rotation at a configurable threshold with a default of 2^30 queries. This provides query-bounded security guarantees. New sessions require fresh setup with a new session identifier.

## Security Considerations

The implementation provides two parameter tiers. Tier 1 uses conservative parameters based on unstructured LPN assumptions targeting 128-bit security and is recommended for production use. Tier 2 uses structured matrix optimizations targeting 150-bit security with safety buffer and includes runtime sanity checks, suitable only when performance is critical.

The freshness trusted computing base requires several operational guarantees for production deployment. Rollback-resistant storage ensures epoch persistence survives VM snapshot and restore operations. Durable allocation requires high-watermark persistence with fsync before use. The authenticated control plane maintains session ID and epoch distribution integrity. Monitoring should alert on unexpected epoch rotation or reuse attempts.

## Documentation

Detailed benchmark analysis is provided in the docs/results directory. The setup cost results document contains measurements of OT versus DPF backend performance. The tile sensitivity results document validates scalability across different tile sizes. The rollback safety results document demonstrates crash recovery validation.

## Project Structure

The project is organized with include/silentmpc containing public headers divided into core types and interfaces, algebra implementations for GF(2), GF(q), and Z_{2^k}, PCF core and evaluation logic, selective delivery backends for OT and DPF, and runtime components for epoch management, allocation, and rotation.

Implementation files are in the src directory matching the include structure. The benchmarks directory contains both performance benchmarks for micro-level testing and paper reproducibility benchmarks that correspond to tables in the paper. Test files in the tests directory provide unit tests requiring GTest. Example programs demonstrate usage patterns. The scripts directory contains utility scripts including network emulation setup.

## Implementation Status

The GF(2) implementation with AVX-512 optimizations is complete with optimized vector operations. Z_{2^k} support for k up to 64 bits is complete with single-limb arithmetic. Z_{2^k} support for k greater than 64 bits is complete with multi-limb support. The four-term decomposition implementing the core PCF algorithm is complete. The OT-centric backend using IKNP extension is complete. The DPF-centric backend with multi-point batching is complete. The epoch manager with rollback-resistant storage is complete. The allocator implementing waste-not-reuse semantics is complete. Session rotation providing query-bounded security is complete. The GF(q) implementation has a complete interface but field arithmetic is in progress.

## Performance Optimization

For LAN deployments, use the OT-centric backend for lower bandwidth consumption. Enable AVX-512 instructions if the processor supports them. Increase tile size to improve throughput through better amortization.

For WAN deployments, use the DPF-centric backend for latency resilience. Pre-compute setup states to reduce online latency. Batch correlation requests to amortize network overhead.

For high reliability requirements, use Tier 1 conservative parameters. Enable epoch persistence with fsync for durability. Monitor rotation events to detect anomalies. Set appropriate session rotation thresholds based on security requirements.

## Contributing

Contributions are welcome following standard practices. Fork the repository and create a feature branch for changes. Add tests for new functionality to maintain code quality. Ensure all tests pass before submission. Submit a pull request with a clear description of changes.

Priority areas for contribution include completing the GF(q) field implementation, developing additional backend optimizations, creating platform-specific optimizations for ARM and GPU architectures, extending parameter sets for different security levels, and providing integration examples for common MPC protocols.

## Testing

The test suite can be run comprehensively or selectively. Run all tests using CTest with verbose output. Specific test suites can be selected using regular expression matching for algebra tests, PCF tests, runtime tests, or backend tests.

```bash
cd build
ctest -V
ctest -R algebra_tests
ctest -R pcf_tests
ctest -R runtime_tests
ctest -R backend_tests
```

Performance benchmarks provide micro-level performance analysis when Google Benchmark is available. Paper reproducibility benchmarks validate the published results and are always built.

## Acknowledgments

This implementation builds on research in silent OT extension protocols, distributed point functions, pseudorandom correlation functions, and secure multi-party computation. The design incorporates lessons from practical MPC system deployments and operational security considerations.

## Technical Specifications

The implementation is written in C++20 and is production-ready with validated benchmarks. Full support is provided for Linux systems with partial support for macOS and Windows via WSL2. The codebase uses modern C++ features including concepts, ranges, and coroutines where applicable for clean and efficient implementations.
